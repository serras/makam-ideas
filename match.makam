
zero : type.
succ : type -> type.

mapU : (A -> A -> prop) -> list A -> list A -> prop.
mapU F S S :- refl.isunif S.
mapU F [] [].
mapU F (A :: As) (B :: Bs) :- F A B, mapU F As Bs.

placeholderlist : list A.

mapN : list B -> (A -> B -> prop) -> list A -> list B -> prop.
mapN Placeholder F S Placeholder :- refl.isunif S.
mapN Placeholder F [] [].
mapN Placeholder F (A :: As) (B :: Bs)
  :- F A B, mapN Placeholder F As Bs.

(* SIMPLE SYNTAX OF LAMBDA TERMS *)

term : type.
k   : string -> term.
lam : (term -> term) -> term.
app : term -> list term -> term.
star : term.  (* only for novars checking *)

(* patterns follow the icfp'18 paper *)
altrhs : (N: type) -> type.
altbind : (term -> altrhs N) -> altrhs (succ N).
altbody : term -> altrhs zero.

pat  : (NBefore: type) (NAfter: type) -> type.
pats : (NBefore: type) (NAfter: type) -> type.
patvar : pat N (succ N).
patk   : string -> pats N M -> pat N M.
patsnil  : pats N N.
patscons : pat N M -> pats M O -> pats N O.

alt : type.
alt : pat zero N -> altrhs N -> alt.
case : term -> list alt -> term.

(* remove nested apps *)
normalize  : term -> term -> prop.
normalize' : term -> term -> prop.
normalizeA : alt -> alt -> prop.
normalizeR : [N] altrhs N -> altrhs N -> prop.
normalize X X
  :- refl.isunif X.
normalize X Y
  :- not(refl.isunif X), normalize' X Y.
normalize' (k X) (k Y) :- eq X Y.
normalize' (lam Body) (lam BodyN)
  :- (x:term -> normalize' x x -> normalize (Body x) (BodyN x)).
normalize' (app Fun []) FunN
  :- normalize Fun FunN.
normalize' (app App Args2) Norm
  :- not(refl.isunif App), eq App (app Head Args1),
     append Args1 Args2 Args, normalize (app Head Args) Norm.
normalize' (app Head Args) (app HeadN ArgsN)
  :- not(eq Args []), normalize Head HeadN, mapU normalize Args ArgsN.
normalize' (case E Alts) (case EN AltsN)
  :- normalize E EN, mapU normalizeA Alts AltsN.
normalizeA (alt P R) (alt P RN)
  :- normalizeR R RN.
normalizeR (altbody E) (altbody EN)
  :- normalize E EN.
normalizeR (altbind E) (altbind EN)
  :- (x:term -> normalize' x x -> normalizeR (E x) (EN x)).

(* replace all variables by ** *)
notvars  : term -> term -> prop.
notvars' : term -> term -> prop.
notvarsA : alt -> alt -> prop.
notvarsR : [N] altrhs N -> altrhs N -> prop.
notvars X star
  :- refl.isunif X.
notvars X Y
  :- not(refl.isunif X), notvars' X Y.
notvars' (k X) (k X).
notvars' (lam Body) (lam BodyN)
  :- (x:term -> notvars' x x -> notvars (Body x) (BodyN x)).
notvars' (app Head Args) (app HeadN ArgsN)
  :- notvars Head HeadN, mapN placeholderlist notvars Args ArgsN.
notvars' (case E Alts) (case EN AltsN)
  :- notvars E EN, mapN placeholderlist notvarsA Alts AltsN.
notvarsA (alt P R) (alt P RN)
  :- notvarsR R RN.
notvarsR (altbody E) (altbody EN)
  :- notvars E EN.
notvarsR (altbind E) (altbind EN)
  :- (x:term -> notvars' x x -> notvarsR (E x) (EN x)).

(* beta-reduce the top *)
betaReduceTop : term -> term -> prop.
betaReduceTop (app T []) Y 
  :- betaReduceTop T Y.
betaReduceTop (app (lam F) (Arg :: Rest)) Y
  :- betaReduceTop (app (F Arg) Rest) Y.
betaReduceTop X X
  :- not(eq X (app (lam _) _)).

existpat : type.
existpat : pat zero N -> existpat.
getpat : alt -> existpat -> prop.
getpat (alt Pat _) (existpat Pat).

(* REWRITINGS *)

r : type.
patr : type.
(* structural rewritings *)
inappl  : r -> r.
inappr  : r -> r.
inlam   : r -> r.
incasee : r -> r.
incasea : r -> r.
(* semi-real rewritings *)
betareduce : r.
betaexpand : r.
etaexpand  : r.
(* reorder, add, drop matches *)
patmatch   : list patr -> r.
addpat     : existpat -> patr.
droppat    : existpat -> patr.
(* real rewritings *)
npluszero : r.
defn_id   : r.
compose   : r.
expandmap : r.
(* mistakes *)
wrong_parens : r.

place : type.
instudent : place.
inmodel   : place.

rewriting : type.
rw : place -> r -> term -> rewriting.

match' : (term -> term) -> (term -> term) -> (term -> list rewriting) -> prop.
match : term -> term -> term -> list rewriting -> prop.
matchOneStep : term -> term -> term -> place -> r -> term -> term -> prop.
choosefromplace : term -> term -> place -> term -> prop.
onestep : term -> term -> term -> term -> term -> place -> r -> prop.
onestepany : term -> term -> term -> r -> prop.
onestepalt : term -> alt -> alt -> alt -> alt -> place -> r -> prop.
onesteprhs : [N] term -> altrhs N -> altrhs N -> altrhs N -> altrhs N -> place -> r -> prop.
onesteplist : (A -> A -> A -> A -> place -> r -> prop)
              -> list A -> list A -> list A -> list A -> place -> r -> prop.

visited : place -> term -> prop.

match' S M R :- (f:term -> normalize' f f -> notvars' f f -> match f (S f) (M f) (R f)).

match Me X X [].
match Me S M ((rw P R T) :: Rs)
  :- not(refl.isunif S), not(eq S M),
     onestep Me S S1 M M1 P R,
     normalize S1 S2, normalize M1 M2,
     choosefromplace S2 M2 P T,
     (* check that we haven't been there yet *)
     print "", print "next", print S2, print M2, print P, print R,
     notvars S2 SNo, notvars M2 MNo,
     (eq S2 M2 ; not(visited instudent SNo) ; not(visited inmodel MNo)),
     (visited instudent SNo -> visited inmodel MNo -> match Me S2 M2 Rs).

matchOneStep Me S M P R S2 M2
  :- not(refl.isunif S), not(eq S M), 
     onestep Me S S1 M M1 P R, 
     normalize S1 S2, normalize M1 M2,
     choosefromplace S2 M2 P T.

choosefromplace S M instudent S.
choosefromplace S M inmodel   M.

onestep Me (app (k "+") [k "0", X]) X M M instudent npluszero.

onestep Me C C
        (app (k "map") [F,Xs])
        (case Xs [ alt (patk "[]" patsnil) (altbody (k "[]"))
                 , alt (patk ":" (patscons patvar (patscons patvar patsnil)))
                       (altbind (fun x => altbind (fun xs => altbody (
                         app (k ":") [FX x xs, MeXs x xs]
                       ))))
                 ]) inmodel expandmap
  :- not(refl.isunif C), eq C (case _ _), (* do not refine if the case is not there *)
     (x:term -> xs:term -> (betaReduceTop (app F [x]) (FX x xs), betaReduceTop (app Me [xs]) (MeXs x xs))).

(* rules which apply in any side *)
onestep Me S S' M M instudent R :- onestepany Me S S' R.
onestep Me S S M M' inmodel   R :- onestepany Me M M' R.

(* a special one, you should never guess from these rules *)
onestepany Me (app KId (X :: Rest)) (app X Rest) defn_id
  :- eq_nounif KId (k "id").
onestepany Me (app KComp (F :: G :: X :: R)) (app F (app G [X] :: R)) compose
  :- eq_nounif KComp (k ".").

(* match the patterns in a case *)
reorderaddmatches : list alt -> list alt -> list alt -> list patr -> prop.
dropmatches       : list alt -> list alt -> list patr -> prop.
findalt           : list alt -> existpat -> alt -> prop.

onestep Me (case S A1) (case S A2) (case M B) (case M B) instudent (patmatch Rs)
  :- mapN [] getpat A1 PatA, mapN [] getpat B PatB, not(eq PatA PatB), (* apply if not already equal *)
     reorderaddmatches A1 A2 B Rs1, dropmatches A1 B Rs2, append Rs1 Rs2 Rs.

reorderaddmatches As [] [] [].
reorderaddmatches As (A :: NextAs) ((alt P _) :: Ms) Rs
  :- findalt As (existpat P) A, reorderaddmatches As NextAs Ms Rs.
reorderaddmatches As ((alt P E) :: NextAs) ((alt P E) :: Ms) (addpat (existpat P) :: Rs)
  :- not(findalt As (existpat P) _), reorderaddmatches As NextAs Ms Rs.

dropmatches [] Ms [].
dropmatches ((alt P _) :: As) Ms Rs
  :- findalt Ms (existpat P) _, dropmatches As Ms Rs.
dropmatches ((alt P _) :: As) Ms (droppat (existpat P) :: Rs)
  :- not(findalt Ms (existpat P) _), dropmatches As Ms Rs.

findalt ((alt P E) :: Alts) (existpat P) (alt P E).
findalt (_ :: Alts) P R :- findalt Alts P R.

(* beta and eta rules, do not apply on variables *)
onestep Me (app L [X]) (F X)              M M instudent betareduce
  :- not(refl.isunif L), eq L (lam F), not(refl.isunif F).
onestep Me (app L (X :: Rest)) (app (F X) Rest) M M instudent betareduce
  :- not(refl.isunif L), eq L (lam F), not(refl.isunif F), not(eq Rest []).
onestep Me L L M (lam (fun x => app M [x])) inmodel etaexpand
  :- not(refl.isunif L), eq L (lam F), not(refl.isunif F),
     not(eq M (lam _)).  (* do not expand if lambda *)

(* expand variables *)
onestep Me (app L MiniArgs) (app L MiniArgs) (app M MaxiArgs) (app M MaxiArgs) instudent betaexpand
  :- refl.isunif L, append RestArgs MiniArgs MaxiArgs, not(eq RestArgs []), eq L (app T RestArgs).
(* nested applications *)
onestep Me (app F Xs) (app F Xs) (app G Gs) (app G Gs) instudent betaexpand
  :- refl.isunif F, append PreX1 [X] Xs, (* student = f prex1 x *)
     append PreH [app H Hs] Gs, append PreX2 [X] Hs, (* model = g preh (h prex2 x) *)
     normalize (app G PreH) AppGNorm, normalize (app H PreX2) AppHNorm,
     eq F (app (k ".") [AppGNorm, AppHNorm]).

(* mistakes, last option *)
(* wrong parens -> `x y z` turns into `x (y z)` *)
onestep Me (app F (G :: Args)) (app F [app G Args])
           (app F' [A']) (app F' [A']) instudent wrong_parens
  :- not(eq Args []), not (eq F' (lam _)).

(* structural, only go if rewrite doesn't work *)
onestep Me (lam S) (lam S') (lam M) (lam M') P (inlam R)
  :- (x:term -> onestep Me (S x) (S' x) (M x) (M' x) P R).
onestep Me (app S1 S) (app S2 S) (app M1 M) (app M2 M) P (inappl R)
  :- onestep Me S1 S2 M1 M2 P R.
onestep Me (app S S1) (app S S2) (app M M1) (app M M2) P (inappr R)
  :- onesteplist (onestep Me) S1 S2 M1 M2 P R.
onestep Me (case S1 S) (case S2 S) (case M1 M) (case M2 M) P (incasee R)
  :- onestep Me S1 S2 M1 M2 P R.
onestep Me (case S S1) (case S S2) (case M M1) (case M M2) P (incasea R)
  :- onesteplist (onestepalt Me) S1 S2 M1 M2 P R.
onestepalt Me (alt Pat S1) (alt Pat S2) (alt Pat M1) (alt Pat M2) P R
  :- onesteprhs Me S1 S2 M1 M2 P R.
onesteprhs Me (altbody S1) (altbody S2) (altbody M1) (altbody M2) P R
  :- onestep Me S1 S2 M1 M2 P R.
onesteprhs Me (altbind S1) (altbind S2) (altbind M1) (altbind M2) P R
  :- (x:term -> onesteprhs Me (S1 x) (S2 x) (M1 x) (M2 x) P R).
onesteplist F (S :: Ss) (S' :: Ss) (M :: Ms) (M' :: Ms) P R
  :- F S S' M M' P R.
onesteplist F (S :: Ss) (S :: Ss') (M :: Ms) (M :: Ms') P R
  :- onesteplist F Ss Ss' Ms Ms' P R.
