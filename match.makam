%open syntax.

zero : type.
succ : type -> type.

(* SIMPLE SYNTAX OF LAMBDA TERMS *)

term : type.
k   : string -> term.
lam : (term -> term) -> term.
fix : (term -> term) -> term.
app : term -> list term -> term.

(* patterns follow the icfp'18 paper *)
altrhs : (N: type) -> type.
altbind : (term -> altrhs N) -> altrhs (succ N).
altbody : term -> altrhs zero.

pat  : (NBefore: type) (NAfter: type) -> type.
pats : (NBefore: type) (NAfter: type) -> type.
patvar : pat N (succ N).
patk   : string -> pats N M -> pat N M.
patsnil  : pats N N.
patscons : pat N M -> pats M O -> pats N O.

alt : type.
alt : pat zero N -> altrhs N -> alt.
case : term -> list alt -> term.

(* remove nested apps *)
normalize  : term -> term -> prop.
normalize' : term -> term -> prop.
normalizeA : alt -> alt -> prop.
normalizeR : [N] altrhs N -> altrhs N -> prop.
normalize X X
  :- refl.isunif X.
normalize X Y
  :- not(refl.isunif X), normalize' X Y.
normalize' (k X) (k Y) :- eq X Y.
normalize' (lam Body) (lam BodyN)
  :- (x:term -> normalize' x x -> normalize (Body x) (BodyN x)).
normalize' (fix Body) (fix BodyN)
  :- (x:term -> normalize' x x -> normalize (Body x) (BodyN x)).
normalize' (app Fun []) FunN
  :- normalize Fun FunN.
normalize' (app App Args2) Norm
  :- not(refl.isunif App), eq App (app Head Args1),
     append Args1 Args2 Args, normalize (app Head Args) Norm.
normalize' (app Head Args) (app HeadN ArgsN)
  :- not(eq Args []), normalize Head HeadN, map normalize Args ArgsN.
normalize' (case E Alts) (case EN AltsN)
  :- normalize E EN, map normalizeA Alts AltsN.
normalizeA (alt P R) (alt P RN)
  :- normalizeR R RN.
normalizeR (altbody E) (altbody EN)
  :- normalize E EN.
normalizeR (altbind E) (altbind EN)
  :- (x:term -> normalize' x x -> normalizeR (E x) (EN x)).

(* replace all variables by ** *)
notvars  : term -> term -> prop.
notvars' : term -> term -> prop.
notvarsA : alt -> alt -> prop.
notvarsR : [N] altrhs N -> altrhs N -> prop.
notvars X (k "**")
  :- refl.isunif X.
notvars X Y
  :- not(refl.isunif X), notvars' X Y.
notvars' (k X) (k X).
notvars' (lam Body) (lam BodyN)
  :- (x:term -> notvars' x x -> notvars (Body x) (BodyN x)).
notvars' (fix Body) (fix BodyN)
  :- (x:term -> notvars' x x -> notvars (Body x) (BodyN x)).
notvars' (app Head Args) (app HeadN ArgsN)
  :- notvars Head HeadN, map notvars Args ArgsN.
notvars' (case E Alts) (case EN AltsN)
  :- notvars E EN, map notvarsA Alts AltsN.
notvarsA (alt P R) (alt P RN)
  :- notvarsR R RN.
notvarsR (altbody E) (altbody EN)
  :- notvars E EN.
notvarsR (altbind E) (altbind EN)
  :- (x:term -> notvars' x x -> notvarsR (E x) (EN x)).

existpat : type.
existpat : pat zero N -> existpat.
getpat : alt -> existpat -> prop.
getpat (alt P _) (existpat P).

parse : string -> term -> prop.
(* defined later *)

(* REWRITINGS *)

r : type.
patr : type.
(* structural rewritings *)
inappl  : r -> r.
inappr  : r -> r.
inlam   : r -> r.
infix   : r -> r.
incasee : r -> r.
incasea : r -> r.
(* semi-real rewritings *)
betareduce : r.
etaexpand  : r.
introfix   : r.
(* reorder, add, drop matches *)
patmatch   : list patr -> r.
addpat     : existpat -> patr.
droppat    : existpat -> patr.
(* real rewritings *)
npluszero : r.
defn_id   : r.
compose   : r.
(* mistakes *)
wrong_parens : r.

place : type.
instudent : place.
inmodel   : place.

rewriting : type.
rw : place -> r -> term -> rewriting.

match : term -> term -> list rewriting -> prop.
matchOneStep : term -> term -> place -> r -> term -> term -> prop.
choosefromplace : term -> term -> place -> term -> prop.
onestep : term -> term -> term -> term -> place -> r -> prop.
onestepany : term -> term -> r -> prop.
onestepalt : alt -> alt -> alt -> alt -> place -> r -> prop.
onesteprhs : [N] altrhs N -> altrhs N -> altrhs N -> altrhs N -> place -> r -> prop.
onesteplist : (A -> A -> A -> A -> place -> r -> prop)
              -> list A -> list A -> list A -> list A -> place -> r -> prop.

visited : place -> term -> prop.

match X X [].
match S M ((rw P R T) :: Rs)
  :- not(refl.isunif S), not(eq S M), 
     onestep S S1 M M1 P R,
     normalize S1 S2, normalize M1 M2,
     choosefromplace S2 M2 P T,
     (* check that we haven't been there yet *)
     (* print "", print "iter", print S2, print M2, *)
     notvars S2 SNo, notvars M2 MNo,
     (not(visited instudent SNo) ; not(visited inmodel MNo)),
     (visited instudent SNo -> visited inmodel MNo -> match S2 M2 Rs).

matchOneStep S M P R S2 M2
  :- not(refl.isunif S), not(eq S M), 
     onestep S S1 M M1 P R, 
     normalize S1 S2, normalize M1 M2,
     choosefromplace S2 M2 P T.

choosefromplace S M instudent S.
choosefromplace S M inmodel   M.

onestep (app (k "+") (k "0" :: X :: [])) X M M instudent npluszero.

(* rules which apply in any side *)
onestep S S' M M instudent R :- onestepany S S' R.
onestep S S M M' inmodel   R :- onestepany M M' R.

(* mistakes *)
(* wrong parens -> `x y z` turns into `x (y z)` *)
onestep (app F (G :: Args)) (app F (app G Args :: []))
        (app F' (A' :: [])) (app F' (A' :: [])) instudent wrong_parens.

(* match the patterns in a case *)
reorderaddmatches : list alt -> list alt -> list alt -> list patr -> prop.
dropmatches       : list alt -> list alt -> list patr -> prop.
findalt           : list alt -> existpat -> alt -> prop.

onestep (case S A1) (case S A2) (case M B) (case M B) instudent (patmatch Rs)
  :- map getpat A1 PatA, map getpat B PatB, not(eq PatA PatB), (* apply if not already equal *)
     reorderaddmatches A1 A2 B Rs1, dropmatches A1 B Rs2, append Rs1 Rs2 Rs.

reorderaddmatches As [] [] [].
reorderaddmatches As (A :: NextAs) ((alt P _) :: Ms) Rs
  :- findalt As (existpat P) A, reorderaddmatches As NextAs Ms Rs.
reorderaddmatches As ((alt P E) :: NextAs) ((alt P E) :: Ms) (addpat (existpat P) :: Rs)
  :- not(findalt As (existpat P) _), reorderaddmatches As NextAs Ms Rs.

dropmatches [] Ms [].
dropmatches ((alt P _) :: As) Ms Rs
  :- findalt Ms (existpat P) _, dropmatches As Ms Rs.
dropmatches ((alt P _) :: As) Ms (droppat (existpat P) :: Rs)
  :- not(findalt Ms (existpat P) _), dropmatches As Ms Rs.

findalt ((alt P E) :: Alts) (existpat P) (alt P E).
findalt (_ :: Alts) P R :- findalt Alts P R.

(* a special one, you should never guess from these rules *)
onestepany (app KId (X :: Rest)) (app X Rest) defn_id
  :- eq_nounif KId (k "id").
onestepany (app KComp (F :: G :: X :: R)) (app F (app G (X :: []) :: R)) compose
  :- eq_nounif KComp (k ".").

(* beta and eta rules, do not apply on variables *)
onestep (app L (X :: [])) (F X)              M M instudent betareduce
  :- not(refl.isunif L), eq L (lam F), not(refl.isunif F).
onestep (app L (X :: Rest)) (app (F X) Rest) M M instudent betareduce
  :- not(refl.isunif L), eq L (lam F), not(refl.isunif F), not(eq Rest []).
onestep L L M (lam (fun x => app M (x :: []))) inmodel etaexpand
  :- not(refl.isunif L), eq L (lam F), not(refl.isunif F),
     not(eq M (lam _)), not(eq M (fix _)).  (* do not expand if lambda or fix *)
onestep S (fix (fun x => S)) (fix M) (fix M) instudent introfix
  :- not(eq S (fix _)).

(* structural, only go if rewrite doesn't work *)
onestep (lam S) (lam S') (lam M) (lam M') P (inlam R)
  :- (x:term -> onestep (S x) (S' x) (M x) (M' x) P R).
onestep (fix S) (fix S') (fix M) (fix M') P (infix R)
  :- (x:term -> onestep (S x) (S' x) (M x) (M' x) P R).
onestep (app S1 S) (app S2 S) (app M1 M) (app M2 M) P (inappl R)
  :- onestep S1 S2 M1 M2 P R.
onestep (app S S1) (app S S2) (app M M1) (app M M2) P (inappr R)
  :- onesteplist onestep S1 S2 M1 M2 P R.
onestep (case S1 S) (case S2 S) (case M1 M) (case M2 M) P (incasee R)
  :- onestep S1 S2 M1 M2 P R.
onestep (case S S1) (case S S2) (case M M1) (case M M2) P (incasea R)
  :- onesteplist onestepalt S1 S2 M1 M2 P R.
onestepalt (alt Pat S1) (alt Pat S2) (alt Pat M1) (alt Pat M2) P R
  :- onesteprhs S1 S2 M1 M2 P R.
onesteprhs (altbody S1) (altbody S2) (altbody M1) (altbody M2) P R
  :- onestep S1 S2 M1 M2 P R.
onesteprhs (altbind S1) (altbind S2) (altbind M1) (altbind M2) P R
  :- (x:term -> onesteprhs (S1 x) (S2 x) (M1 x) (M2 x) P R).
onesteplist F (S :: Ss) (S' :: Ss) (M :: Ms) (M' :: Ms) P R
  :- F S S' M M' P R.
onesteplist F (S :: Ss) (S :: Ss') (M :: Ms) (M :: Ms') P R
  :- onesteplist F Ss Ss' Ms Ms' P R.

(* PARSE LAMBDA TERMS *)

preterm : type.
listpreterm : type.
prevar : string -> preterm.
prelam : string -> preterm -> preterm.
preapp : listpreterm -> preterm.
precons : preterm -> listpreterm -> listpreterm.
preone  : preterm -> listpreterm.

preterm, basepreterm : syntax preterm.
listbasepreterm : syntax listpreterm.
`(syntax_rules <<
basepreterm ->
    { "(" <preterm> ")"}
  / prelam { "lambda" <makam.ident> ":" <preterm> }
  / prevar { <makam.ident> }
preterm ->
    preapp { <listbasepreterm> }
listbasepreterm ->
    precons { <basepreterm> <listbasepreterm> }
  / preone  { <basepreterm> }
>>).
`(syntax.def_toplevel_js preterm).

to_term  : preterm -> term -> prop.
to_terms : listpreterm -> list term -> prop.
bound    : string  -> term -> prop.
to_term (prevar X) V :- bound X V.
to_term (prevar X) (k X) :- not(bound X V).
to_term (prelam X B) (lam (fun x => E x))
  :- (x:term -> bound X x -> to_term B (E x)).
to_term (preapp (preone H)) H'
  :- to_term H H'.
to_term (preapp (precons H R)) (app H' R')
  :- to_term H H', to_terms R R'.
to_terms (precons T Ts) (T' :: Ts')
  :- to_term T T', to_terms Ts Ts'.
to_terms (preone T) (T' :: [])
  :- to_term T T'.

parse Input LamN
  :- syntax.run preterm Input Pre,
     to_term Pre Lam, normalize Lam LamN.

