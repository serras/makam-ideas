(** IMPORTANT: always introduce a term f for the fixpoint **)

(* simple *)
(f:term -> match f (lam (fun x => app (k "map") (k "replicate" :: k "2" :: []))) (lam (fun x => app (k "map") [app (k "replicate") [k "2"] ])) R) ?
(f:term -> match f (lam (fun x => app (X f x) (k "0" :: x :: []))) (k "id") R) ?
(f:term -> match f (lam (fun x => app (X f x) (k "0" :: []))) (k "id") R) ?
(f:term -> match f (lam (fun x => app (X f x) (x :: []))) (k "id") R) ?
(f:term -> match f (lam (fun x => (X f x))) (lam (fun x => app f (x :: []))) R) ?

(* pattern matching *)
(f:term -> match f
      (lam (fun t => case t
                          [ alt (patk ":" (patscons patvar (patscons patvar patsnil)))
                                (altbind (fun x => altbind (fun xs => altbody (X t x xs))))
                          , alt (patk "[]" patsnil) (altbody (Y t))
                          ] ))
      (lam (fun t => case t
                          [ alt (patk "[]" patsnil) (altbody (k "nothing"))
                          , alt (patk ":" (patscons patvar (patscons patvar patsnil)))
                                (altbind (fun x => altbind (fun xs => altbody (
                                  app (k "just") (x :: [])
                                ))))
                          ] ))
      R) ?
(f:term -> match f
      (lam (fun t => case t [ alt (patk ":" (patscons patvar (patscons patvar patsnil)))
                                  (altbind (fun x => altbind (fun xs => altbody (X t x xs))))
                            , P ]))
      (lam (fun t => case t
                          [ alt (patk "[]" patsnil) (altbody (k "nothing"))
                          , alt (patk ":" (patscons patvar (patscons patvar patsnil)))
                                (altbind (fun x => altbind (fun xs => altbody (
                                  app (k "just") (x :: [])
                                ))))
                          ] ))
      R) ?

(* composition *)
(f:term -> match f (lam (fun x => app (X x) [x])) (app (k ".") [k "bli", k "blu"]) R) ?
(f:term -> match f (lam (fun x => app (X x) [x])) (lam (fun x => app (k "bli") [app (k "blu") [x]])) R) ?